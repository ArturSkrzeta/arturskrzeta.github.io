	<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Learn SQL Application</h2>

										<h3>Intro</h3>

										<p style="text-align: justify;">SQL is the declarative lanuguage which we use to say what we want to get and computer needs to figure out the computation tasks to provide quieried result.
											In this post I put my notes and examples that helps me to understand different aspects of SQL. There is also the application for learning SQL demonstrated in the <a href="#three"><u>Demo</u></a> section and its source code linked below.</p>

										<h5>In this section I describe following concepts:</h5>
										<ul>
											<a href="#primary_and_foreign_key"><li>Primary and foreign key</li></a>
											<a href="#query_types"><li>Query types</li></a>
											<a href="#constraints"><li>Constraints</li></a>
											<a href="#stored_procedures"><li>Stored procedures</li></a>
											<a href="#database_normalization"><li>Database normalization</li></a>
											<a href="#one_to_many-many"><li>One-to-many</li></a>
											<a href="#many_to_many"><li>Many-to-many</li></a>
											<a href="#variables"><li>Variables</li></a>
											<a href="#oltp_and_olap"><li>OLTP and OLAP</li></a>
											<a href="#functions"><li>Functions</li></a>
											<a href="#window_functions"><li>Window functions</li></a>
										</ul>

										<h5>Also some SQL syntax elements:</h5>
										<ul>
											<a href="#like"><li>LIKE</li></a>
											<a href="#index"><li>INDEX</li></a>
											<a href="#view"><li>VIEW</li></a>
											<a href="#distinct"><li>DISTINCT</li></a>
											<a href="#join"><li>JOIN</li></a>
											<a href="#self_join"><li>SELF JOIN</li></a>
											<a href="#using"><li>USING</li></a>
											<a href="#union"><li>UNION</li></a>
											<a href="#except"><li>EXCEPT</li></a>
											<a href="#intersect"><li>INTERSECT</li></a>
											<a href="#order_by"><li>ORDER BY</li></a>
											<a href="#limit"><li>LIMIT</li></a>
											<a href="#top"><li>TOP</li></a>
											<a href="#where"><li>WHERE</li></a>
											<a href="#case"><li>CASE</li></a>
											<a href="#group_by"><li>GROUP BY</li></a>
											<a href="#having"><li>HAVING</li></a>
											<a href="#in"><li>IN</li></a>
											<a href="#over"><li>OVER</li></a>
											<a href="#offset"><li>OFFSET</li></a>
											<a href="#fetch"><li>FETCH</li></a>
											<a href="#exist"><li>EXISTS</li></a>
										</ul>

										<h5>Terminology and general aspects</h5>
										<ul>
											<li id="primary_and_foreign_key"><b>Primary key</b> - a column or columns combination that idetifies a specific row uniquely. It implies NOT NULL constraint and hast to be UNIQUE.</li>
											<li><b>Foreign key</b> - a column that contains a primary key of a record from another table. This way we build relationship between tables.
												<br><br>
												<table>
												<tr style="background-color: #223639; color: #ffff;">
													<td>
													customers<br>
													- <u>customer_id: <span style="color:#00ffea;">pk</span> integer</u><br>
													- phone: string<br>
													- email: string
													</td>
													<td>
													orders<br>
													- order_id: integer<br>
													- status: string<br>
													- <u>customer_id: <span style="color:#00ffea;">fk</span> integer</u>
													</td>
												</tr>
												</table>
												- In above example pk stands for primary key and fk stands for foreign key.<br>
												- In one to many relationship: one customer can have many orders, so we can find one customer multiple times in the orders table.<br>
												- As per one to many relationship, one order cannot have multiple customers.<br>
												<span style="font-size:14px;">orderd table</span>
												<table style="font-size:16px;">
													<thead>
														<tr>
															<th>order_id</th>
															<th>status</th>
															<th>customer_id</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>1</td>
															<td>completed</td>
															<td>1</td>
														</tr>
														<tr>
															<td>2</td>
															<td>completed</td>
															<td>1</td>
														</tr>
														<tr>
															<td>3</td>
															<td>cancelled</td>
															<td>3</td>
														</tr>
														<tr>
															<td>4</td>
															<td>pending</td>
															<td>1</td>
														</tr>
													</tbody>
												</table>
											</li>
											<li>Db engine executes query in the sequence as below:
												<br>
												1. FROM, JOIN - it determines data table(s).<br>
												2. WHERE - records filtering.<br>
												3. GROUP BY - records grouping.<br>
												4. HAVING  - groups filtering.<br>
												5. SELECT - columns filtering.<br>
												6. ORDER BY - results sorting.<br>
											</li>
											<li id="query_types">There are different types of SQL queries:
												<br>
												1. <b>DQL</b> - Data Query Language</b>:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>SELECT</code>.<br>
												2. <b>DML</b> – Data Manipulation Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>.<br>
												3. <b>DDL</b> – Data Definition Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>.<br>
												4. <b>DCL</b> – Data Control Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>GRANT</code>, <code>REVOKE</code>.<br>
												5. <b>TCL</b> - Transaction Control Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>.<br>
											</li>
											<li id="constraints"><b>Constraints</b> - we put the as the limits on the data types of the table. It can be specified while creating or altering the table statement.
													Here they are:
													<br>
													- NOT NULL prevents from keeping nulls in the column.<br>
													- CHECK limits the value range that can placed in the column for instance:<br>
													 	&nbsp&nbsp&nbspAge INTEGER, CHECK (AGE>=18).<br>
													- DEFAULT provides default value to all records unless other value specified.<br>
													- UNIQUE prevents from storing duplicates within a column.<br>
													- PRIMARY KEY sets pk on a column.<br>
													- FOREIGN KEY sets fk indicating pk of a table in the relationship.<br>
											</li>
											<li><b>Data integrity</b> - defines the accuracy as well as the consistency of the data stored in a database.
													Once data integrity ensured then any addition or deletion of data from the table will not create any mismatch in the relationship of the tables.
											</li>
											<li id="stored_procedures"><b>Stored procedure</b> - saved SQL code so that it can be reused anytime with or without passed parameters:
												<br>
												- stored procedure syntax:
<!-- start -->
<pre>
CREATE PROCEDURE procedure_name
AS
sql_statement
GO;
</pre>
<!-- end -->
												- executing stored procedure:
<!-- start-->
<pre>
EXEC procedure_name
</pre>
<!-- end -->
												- here how it looks like with parameters:
<!-- start -->
<pre>
CREATE PROCEDURE SelectAllEmployees <span style="background-color:#3976b3;">@City nvarchar(30)</span>, <span style="background-color:#3976b3;">@PostalCode nvarchar(10)</span>
AS
SELECT * FROM employees WHERE City = <span style="background-color:#3976b3;">@City</span> AND PostalCode = <span style="background-color:#3976b3;">@PostalCode</span>
GO;
</pre>
<!-- end -->
												- calling it with parameters:
<!-- start -->
<pre>
EXEC SelectAllCustomers <span style="background-color:#3976b3;">@City = 'Cracow'</span>, <span style="background-color:#3976b3;">@PostalCode = '30-708'</span>;
</pre>
<!-- end -->
												- They can be used as a modular programming which means creating once, storing and calling many times whenever it's required.<br>
												- This supports faster overall query performance.<br>
												- There is also such thing as <b>recursive stored procedure</b> which calls itself until it reaches some boundary condition. It allows to reuse the same code any number of times.
											</li>
										</ul>

										<h5 id="database_normalization">Database Normalization</h5>
										<ul>
											<li><b>Normalization</b> is the db designing process where we aim for minimizing any data redundancy.
												Redundancy of data means there are multiple copies of the same information spread over multiple locations in the same database.
											</li>
											<li>There are 3 forms of the normalizaton where each consecutive normal form depends on the previous one:
												<br>
												✓ First normal form (1 NF),<br>
												✓ Second normal form (2 NF),<br>
												✓ Third normal form (3 NF),<br>
												where db is considered the third normal form if it meets the requirements of the first 3 normal forms.
											</li>
											<li>In <b>1 NF</b> wa aim to keep only atomic information. Here is the example which violates the 1NF as it contains more than one value for the department column:
												<br><br>
												<span>Assignment table</span>
												<table>
													<tr>
														<td>id</td>
														<td>name</td>
														<td>age</td>
														<td>department</td>
													</tr>
													<tr>
														<td>1</td>
														<td>Artur</td>
														<td>20</td>
														<td>IT, DevOps</td>
													</tr>
													<tr>
														<td>2</td>
														<td>John</td>
														<td>40</td>
														<td>IT, DevOps, DataLab</td>
													</tr>
												</table>
												- Definitely we should be avoiding breaking down department column into a set of new columns like department1, department2, department3. This is what we call <b>repeating groups</b> and it's one of the biggest design error.<br>
												- In order to reach 1 NF, we need to split the table into two tables so that each record can be unique and each cell contains an atomic value:
												<br><br>
												<span>Departments table and assignment table</span>
												<table>
													<tr>

														<td>
															<table style="width:15%;">
																<tr>
																	<td>dep_id</td>
																	<td>dep_name</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>IT</td>
																	<td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>DevOps</td>
																</tr>
																<tr>
																	<td>3</td>
																	<td>DataLab</td>
																</tr>
															</table>
														</td>

														<td>
															<table>
																<tr>
																	<td>emp_id</td>
																	<td>name</td>
																	<td>age</td>
																	<td>dep_id</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>20</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>20</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>40</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>40</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>40</td>
																	<td>3</td>
																</tr>
															</table>
														</td>
													</tr>
												</table>

												- We can move on and make the table in <b>2 NF</b> and <b>3 NF</b>.<br>
												- In 2 NF we care about having single column primary key. In our examples both departments and employees tables has single-column primary key i.e. <b>dep_id</b> and <b>emp_id</b> respecitvely.<br>
												- In 3 NF we get rid of any dependencies on non-key columns. Dependecy can exist only on primary key column.

												<br><br>
												<span>Employees table and assignment table</span>
												<table>
													<tr>

														<td>
															<table style="width:15%;">
																<tr>
																	<td>emp_id</td>
																	<td>emp_name</td>
																	<td>emp_age</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>20</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>40</td>
																</tr>
															</table>
														</td>

														<td>
															<table style="width:15%;">
																<tr>
																	<td>emp_id</td>
																	<td>dep_id</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>3</td>
																</tr>
															</table>
														</td>
													</tr>
												</table>
												- With that solution what we get is <b>many-to-many</b> relationship where many employees can be assigned to one or more departments.<br>
												- Assignment table plays then a role of the connector table that manages many-to-many relationship.<br>
												- Assignment table becomes denormalized table with references to normalized tables.<br>
												- Denormaliaztion is basically combining multiple tables into one for achieving fast data access.
											</li>
											<li>When we care about keeping table normalized we get a set of benefits:
												<br>
												- better db organization,<br>
												- more tables with smaller rows,<br>
												- easy modification,<br>
												- reduction of redundant and duplicate data.<br>
												- ensuring data integrity.
											</li>
										</ul>

										<h5 id="one_to_many">One-to-many relationship</h5>
										<ul>
											<li>When one record from table A can have multiple corresponding records in table B.</li>
											<li>Lets take Products and Categories tables:
												<br>
												<img src="images/one_to_many.png" width="500"><span style="font-size:12px;">source: sqlpedia.pl</span><br>
												- one category can be assigned to many products, however one product cannot be assigned to many categories.
											</li>
										</ul>

										<h5 id="many_to_many">Many-to-many relationship</h5>
										<ul>
											<li>This kind of relationship can be handled by connector table that breaks relationship into two relationships of one-to-many.
													As the example, let's take order system, where each product can be ordered many times in different orders.</li>
											<li>Here are Orders and Products tables connecter with one-to-many relationships with Order Details table.
												<br>
												<img src="images/many_to_many.png" width="600"><span style="font-size:12px;">source: sqlpedia.pl</span>
											</li>
										</ul>

										<h5 id="variables">Variables</h5>
										<ul>
											<li>We can set variable data type, assign a value to it, and use it in the code:
<!-- start -->
<pre>
DECLARE <span style="color:#00ffea;">@TestVariable</span> AS VARCHAR(100)
SET <span style="color:#00ffea;">@TestVariable</span> = 'Thi is an example string.'
PRINT <span style="color:#00ffea;">@TestVariable</span>
</pre>
<!-- end -->
											</li>
											<li>We can display variable value with SELECT or PRINT statements.</li>
											<li>We can also use SELECT statement in order to assing a value to a variable:
<!-- start -->
<pre>
DECLARE <span style="color:#00ffea;">@CarName</span> AS NVARCHAR(50)
SELECT <span style="color:#00ffea;">@CarName</span> = car_model
FROM db.cars
WHERE car_id = 1492
PRINT <span style="color:#00ffea;">@CarName</span>
</pre>
<!-- end -->
												- or:
<!-- start -->
<pre>
DECLARE <span style="color:#00ffea;">@NumCars</span> AS INT
SET <span style="color:#00ffea;">@NumCars</span> = (SELECT COUNT(*) FROM db.cars)
</pre>
<!-- end -->
											</li>
											<li>When we assign multiple-rows SELECT result to a variable, the assigned value to the variable will be the last row of the resultset.</li>
											<li>It's important to remember that local variable scope expires at the end of the batch which can be determined by <b>GO</b> statement</li>
											<li>Thus the lifecycle of variable <code>@TestVariable</code> determines with GO statement line.
													In other words, the variable which is declared above the GO statement line can not be accessed under the GO statement.
											</li>
											<li>Variable scopes:
												<table>
													<thead>
														<tr>
															<td>Local Variable</td>
															<td>Global Variable</td>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>A user declares the local variable.</td>
															<td>The system maintains the global variable. A user cannot declare them.</td>
														</tr>
														<tr>
															<td>By default, a local variable starts with @.</td>
															<td>The global variable starts with @@.</td>
														</tr>
														<tr>
															<td>Can be used or exist inside the function.</td>
															<td>Can be used or exist throughout the program.</td>
														</tr>
													</tbody>
												</table>
											</li>
										</ul>

										<h5 id="oltp_and_olap">OLTP and OLAP</h5>
										<table>
											<thead>
												<tr>
													<td>Online Transaction Processing (OLTP) </td>
													<td>Online Analytical Processing (OLAP)</td>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Online database modifying system.</td>
													<td>Online database data retrieving system.</td>
												</tr>
												<tr>
													<td>Uses traditional DBMS.</td>
													<td>Uses the data warehouse.</td>
												</tr>
												<tr>
													<td>Insert, Update, and Delete operations.</td>
													<td>Mostly select operations.</td>
												</tr>
												<tr>
													<td>Queries are standardized and simple.</td>
													<td>Complex queries involving aggregations.</td>
												</tr>
												<tr>
													<td>Tables are normalized.</td>
													<td>Tables are <u>not</u> normalized.</td>
												</tr>
												<tr>
													<td>Transactions are the sources of data.</td>
													<td>Different OLTP databases become the source of data for OLAP.</td>
												</tr>
												<tr>
													<td>Maintains data integrity constraint.</td>
													<td>Doesn't get frequently modified. Hence, data integrity is not an issue</td>
												</tr>
												<tr>
													<td>Designed for real time business operations.</td>
													<td>Designed for analysis of business measures.</td>
												</tr>
											</tbody>
										</table>

										<h5 id="functions">Functions</h5>
										<ul>
											<li>SQL has many built-in functions that can be categorised in two categories:
												<table>
													<thead>
														<tr>
															<td>Aggregate functions</td>
															<td>Scalar functions</td>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>Perform calculations on a group of values and then return a single value.</td>
															<td>Return a single value from the given input value.</td>
														</tr>
														<tr>
															<td>
																SUM()<br>
																COUNT()<br>
																AVG()<br>
																MIN()<br>
																MAX()<br>
																FIRST()<br>
																LAST()
															</td>
															<td>
																LCASE()<br>
																UCASE()<br>
																LEN()<br>
																MID() / SUBSTRING()<br>
																LOCATE() / CHARINDEX()<br>
																ROUND()<br>
																NOW()<br>
																FORMAT()<br>
																INSTR()<br>
																CONCAT()<br>
																REPLACE()<br>
																YEAR()
															</td>
														</tr>
													</tbody>
												</table>
											</li>
										</ul>

										<h5 id="like">LIKE</h5>
										<ul>
											<li>LIKE operator is used for pattern matching.</li>
											<li>It can be used with wildcards:
												<br>
												- "%"" - matches zero or more characters.<br>
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE emp_surname LIKE 'S%'
</pre>
<!-- end -->
												- "_" - matches exactly one character.
											</li>
										</ul>

										<h5 id="view">VIEW</h5>
										<ul>
											<li>It's a virtual table based on the result of any SQL statement.</li>
											<li>A view contains all you need in every other table: rows and columns and fields can come from one or more real tables.</li>
											<li>While creating views, we can apply <code>WHERE</code> or <code>JOIN</code> statements to keep the data as if it comes from one single table.</li>
											<li>Here is the syntax for view creating:
<!-- start -->
<pre>
CREATE VIEW <span style="background-color:#ad5353;">view_name</span> AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
</pre>
<!-- end -->
												- end here is how to query a view:
<!-- start -->
<pre>
SELECT * FROM <span style="background-color:#ad5353;">view_name</span>
</pre>
<!-- end -->
											</li>
											<li>With views we can restric users from being able to check some confidential data.
													In a view we just define what columns are visible. The columns we want to keep invisible, we don't include them into the view while creating.
													For example, lets say we have the employees table data schema:<br>
													&nbsp&nbsp&nbsp- id: numeric<br>
													&nbsp&nbsp&nbsp- first_name: string<br>
													&nbsp&nbsp&nbsp- last_name: string<br>
													&nbsp&nbsp&nbsp- salary: numeric<br>
													Let's assume that column salary is confidential and has to be restricted from viewing:
<!-- start -->
<pre>
CREATE VIEW <span style="background-color:#ad5353;">emloyess_details</span> AS
SELECT first_name, last_name,
FROM employess
WHERE last_name LIKE 'S%';
</pre>
<!-- end -->
												- When we wat to check salary somehow:
												<!-- start -->
<pre>
SELECT last_name, salary
FROM <span style="background-color:#ad5353;">emloyess_details</span>
WHERE last_name LIKE 'S%';
</pre>
<!-- end -->
												- Querying the view <code>emloyess_details</code> for <code>salary</code> field raises an error.
											</li>
											<li>It aslo simplifies queries hiding their complexity made with UNION, JOIN etc.</li>
										</ul>


										<h5 id="index">INDEX</h5>
										<ul>
											<li>An index is used to speed up searching in the database by reducing records amount to be scanned.</li>
											<li>An index helps to speed up <code>SELECT</code> queries and <code>WHERE</code> clauses, but it slows down data input, with the <code>UPDATE</code> and the <code>INSERT</code> statements.</li>
											<li>Creating an index involves the <code>CREATE INDEX</code> statement, which allows you to name the index, to specify the table and which column or columns to index:
<!-- start -->
<pre>
CREATE INDEX index_name
ON table_name (column_name);
</pre>
<!-- end -->
											</li>
											<li>Updating a table with indexes takes more time than updating a table without (because the indexes also need an update).
													So, only create indexes on columns that will be frequently searched against.
											</li>
											<li>When not to use indexes:
												<br>
												- on small tables,<br>
												- on tables that have frequent, large updates or insert operations,<br>
												- on columns that contain a large number of NULLs,<br>
												- on columns that are frequently manipulated.<br>
											</li>
											<li>Here is how to use it:
												<br>
												- creating index:
<!-- start -->
<pre>
CREATE INDEX employees_last_name_idx
ON employees (<span style="background-color:#3976b3;">last_name</span>);
</pre>
<!-- end -->
												- using indexed column in the select query:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE salary > 10000 AND
    <span style="background-color:#3976b3;">last_name</span> = "Smith"
</pre>
<!-- end -->
												- we use <code>last_name</code> indexed column wihthin WHERE caluse along with <code>salary</code> which speeds up performing the query.<br>
												- It simply works like an index in the book where a specific sections or chapters are indexed with their headings.
											</li>
											<li>We can also index multiple columns, however it takes very long to set it up for the db engine.</li>
											<li>We can say that there are two types of indexes:
												<br>
												<table>
													<thead>
														<tr>
															<td>Clustered Index</td>
															<td>Non-Clustered Index</td>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>Defines the order of storing data in the table</td>
															<td>Doesn't define the order of data inside the table</td>
														</tr>
														<tr>
															<td>As data always can be stored in one way, there can be only one clustered index. When creating a table, the primary key constraint automatically creates index on that column.</td>
															<td>In fact, non-clustered index is stored at different place than table data is stored. This allows for more than one non-clustered index per table.</td>
														</tr>
														<tr>
															<td>Clustered indexes only sort tables. Therefore, they do not consume extra storage.</td>
															<td>Non-clustered indexes are stored in a separate place from the actual table claiming more storage space.</td>
														</tr>
														<tr>
															<td>Fast performance.</td>
															<td>Slower performance as it requires additional lookup between index sotrage and acutal table.</td>
														</tr>
													</tbody>
												</table>
												- It is important to mention here that inside the table the data will be sorted by a clustered index.<br>
												- However, inside the non-clustered index data is stored in the specified order.<br>
												- The non-clustered index contains column values on which the index is created and the address of the corresponding records in the actual table.
											</li>
											<li>Here is how it works:
													<br>
													- When a query is run against indexed column, the database will first go to the index and look for the address of the corresponding row in the table.
												 	It will then go to that row address in the table and fetch other column values.
											</li>
										</ul>

										<h5 id="distinct">DISTINCT</h5>
										<ul>
											<li>Using when we wan to get unique values from a given column.
<!-- start -->
<pre>
SELECT DISTINCT name
FROM students
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="join">JOIN</h5>
										<ul>
											<li>Join is the keyword needed when quering more than one table.</li>
											<li>While joining, we need to define on what columns (of both tables) we will be keeping tables joined.</li>
											<li>Usually, we use primary key of one table matching it with its corresponding foreign key in another table.</li>
											<li>There are a few kind of joins:
												<br>
												- <b>Left join</b>: returns all the rows from the left table regardless if there is a match or a null from the right table.<br>
												- <b>Right join</b>: returns all the rows from the right table regardless if there is a match or a null from the left table.<br>
												- <b>Inner join</b>: returns rows when there is a match in rows between the tables.<br>
												- <b>Full outer join</b>: returns all the rows from the left-hand side table and all the rows from the right-hand side table.<br>
											</li>
											<li>Let's take two table schemas for an example:
												<br><br>
												<table>
												<tr style="background-color: #223639; color: #ffff; font-size:18px;">
													<td>
													tblVideo<br>
													- video_id: PRIMARY KEY integer<br>
													- author_id: integer<br>
													- video_duration: float
													</td>
													<td>
													tblView<br>
													- video_id: FOREIGN KEY integer<br>
													- viewer_id: integer<br>
													- viewer_timewatch: float
													</td>
												</tr>
												</table>
											</li>
											<li>Inner join example:
												<br>
												<i><b>How many publishers have at least one viewer?</b></i>
<!-- start -->
<pre>
SELECT COUNT(DISTINCT vd.author_id)
FROM tblVideo vd
INNER JOIN tblView vw
ON vd.video_id = vw.video_id
</pre>
<!-- end -->
													- It doesn't count authors whose videos are not in the tblView.<br>
													- If I want to count disctinct author's id, I wouldn't need any JOINs and do select only on tblVideo.
											</li>
											<li id="order_by">Left join example:
												<br>
												- Here is the snippet of data schema:
												<br>
												<img src="images/sql_server.JPG" width="420"><span style="font-size:12px">source: toptal.com</span>
<!-- strat -->
<pre>
SELECT i.Id, i.BillingDate, c.Name, r.Name AS ReferredByName
FROM Invoices i
 LEFT JOIN Customers c ON i.CustomerId = c.Id
 LEFT JOIN Customers r ON c.ReferredBy = r.Id
ORDER BY i.BillingDate ASC;
</pre>
<!-- end -->
												- With LEFT JOIN we make sure that all the invoices will be returned no matter what (in case of any NULLs within Customers table).<br>
												- First LEFT JOIN joins customer id pk with customer id fk in the Invoices table.<br>
												- Second LEFT JOIN joins customer id pk with cusotmer id  fk in the Customer table.<br>
												- ORDER BY orders outcome by date. We can append ASC/DESC if ascending or descending ordering.
											</li>
											<li>We can join multiple tables:
<!-- start -->
<pre>
SELECT column1, column2
FROM TableA
JOIN TableB ON TableA.Column3 = TableB.Column3
JOIN TableC ON TableA.Column4 = TableC.Column4
</pre>
<!-- stop -->
											</li>
											<li>We can also join a table with itself what we call <span id="self_join">self join</span>
<!-- start -->
<pre>
	SELECT DISTINCT E.FullName
	FROM EmployeeDetails E
	INNER JOIN EmployeeDetails M
	ON E.EmpID = M.ManagerID;
</pre>
<!-- stop -->
												- We are using different aliases to differentiate tables on join.<br>
												- This way we fetch those emps whose id are present in the ManagerID column.
											</li>
										</ul>

										<h5 id="using">USING</h5>
										<ul>
											<li>USING clause comes in use while working with JOIN and can be used instead of ON clause.</li>
											<li>When we use USING clause, that particular column name should be present in both tables, and the SELECT query will automatically join those tables using the given column name in USING clause.</li>
											<li>Here comes the example:
<!-- start -->
<pre>
SELECT e.emp_id, e.last_name, d.loc_id
FROM emploees e JOIN departments d
USING(dep_id);
</pre>
<!-- end -->
												- in tables employees and departments, dep_id column is the mutual one.
											</li>
										</ul>

										<h5 id="union">UNION</h5>
										<ul>
											<li>Merges the contents of two structurally-compatible tables into a single combined table removing duplicated records.</li>
											<li>There is also UNION ALL that does the same things but keeps duplicated records.</li>
											<li>Performance of UNION ALL is better than UNION, since UNION requires the server to do the additional work of removing any duplicate.</li>
											<li>Here is how to use it:
<!-- start -->
<pre>
SELECT employee_id, first_name, last_name, 'Employee' AS status
FROM employees
UNION
SELECT visitor_id, first_name, last_name, 'Visitor' AS status
FROM visitors
</pre>
<!-- stop -->
												- note that colums selected from both tables have to be in sync with each other.
											</li>
										</ul>

										<h5 id="except">EXCEPT</h5>
										<ul>
											<li>Allows to fetch values from one table that are not in another table.
<!-- start -->
<pre>
CREATE TABLE test_a(id INTEGER);
INSERT INTO test_a(id) VALUES (10);
INSERT INTO test_a(id) VALUES (20);
INSERT INTO test_a(id) VALUES (30);
INSERT INTO test_a(id) VALUES (40);
INSERT INTO test_a(id) VALUES (50);

CREATE TABLE test_b(id INTEGER);
INSERT INTO test_b(id) VALUES (10);
INSERT INTO test_b(id) VALUES (30);
INSERT INTO test_b(id) VALUES (50);

SELECT * FROM test_a
EXCEPT
SELECT * FROM test_b;

----------------------
20, 40
</pre>
<!-- end -->
												- 20 and 40 are the values that are not present in test_b table.
											</li>
										</ul>

										<h5 id="intersect">INTERSECT</h5>
										<ul>
											<li>Fetchs common records between two tables:
<!-- start -->
<pre>
SELECT * FROM EmployeeSalary
INTERSECT
SELECT * FROM ManagerSalary;
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="limit">LIMIT</h5>
										<ul>
											<li>Limiting select query results to specific numbers of records:
<!-- start -->
<pre>
SELECT *
FROM (
	SELECT *
	FROM employees
	ORDER BY salary DESC )
LIMIT 10;
</pre>
<!-- end -->
												- We fetch 10 highest salaries in employees tabel.<br>
												- We use subquery meaning we emebd one select into another.
											</li>
										</ul>

										<h5 id="top">TOP</h5>
										<ul>
											<li>We can select x top records:
												<br>
												- let's assume we have customers table and the fields customer_id,<br>
												- let's fetch first 100 odd cutomer_id values,<br>
												- <span id="where">there, we use WHERE clause to filter fetch rows, this clause allows AND as well as OR operators,</span>
<!-- start -->
<pre>
SELECT TOP 100 customer_id
FROM customers
WHERE customer_id % 2 = 1
ORDER BY user_id
</pre>
<!-- end -->
												- Clause Were can also have BETWEEM operator:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE date_of_joining BETWEEN '2020/01/01' AND '2020/12/31';
</pre>
<!-- end -->
												- When it comes to dates, we can extract what we want:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE YEAR(date_of_joining) = '2020'
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="group_by">GROUP BY</h5>
										<ul>
											<li>Groups rows when they have the same value in the field we indicate:
<!-- start -->
<pre>
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 3;
</pre>
<!-- end -->
												- We count all customers for a specific country but we display countires where count is bigger than 3.<br>
												- We use GROUP BY when some aggregating function in select line like COUNT, SUM, AVERAGE.<br>
												- <span id="having">HAVING simply puts filter on COUNT(CustomerID) outcome column.</span>
<!-- start -->
<pre>
COUNT(CustomerID)	Country
9			Brazil
11			France
11			Germany
5			Mexico
5			Spain
7			UK
13			USA
4			Venezuela
</pre>
<!-- end -->
											</li>
											<li>WHERE vs HAVING:
												<br>
												- When GROUP BY is not used, then WHERE and HAVING clauses works the same.<br>
												- When  GROUP BY is used, then WHERE clause is used to filter records from a result and filtering works before any grouping. HAVING clause is used to filter values from a group.
											</li>
										</ul>


										<h5>Referencing to the same table more than once:</h5>
										<ul>
											<li>Here is the employees table:
												<br><br>
												<table style="font-size:16px;">
													<thead>
														<tr>
															<th>Emp_Id</th>
															<th>Emp_name</th>
															<th>Salary</th>
															<th>Manager_Id</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>10</td>
															<td>Anil</td>
															<td>50000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>11</td>
															<td>Vikas</td>
															<td>75000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>12</td>
															<td>Nisha</td>
															<td>40000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>13</td>
															<td>Nidhi</td>
															<td>60000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>14</td>
															<td>Priya</td>
															<td>80000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>15</td>
															<td>Mohit</td>
															<td>45000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
													</tbody>
												</table>
											</li>
											<li>Lets fetch all rows with WHERE clause on <b>a.manager_id = b.emp_id</b>:
<!-- start -->
<pre>
SELECT *
FROM Employee a, Employee b
WHERE a.manager_id = b.emp_id
</pre>
<!-- end -->
												<table class="employees_query" style="font-size:16px;">
													<tbody>
														<tr>
															<td>10</td>
															<td>Anil</td>
															<td>50000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>11</td>
															<td>Vikas</td>
															<td>75000</td>
															<td>16</td>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>12</td>
															<td>Nisha</td>
															<td>40000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>13</td>
															<td>Nidhi</td>
															<td>60000</td>
															<td>17</td>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>14</td>
															<td>Priya</td>
															<td>80000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>15</td>
															<td>Mohit</td>
															<td>45000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
													</tbody>
												</table>
												- Note there is no Rajesh in the outcome as he has no manager above him. Rajesh appears only as the manager for other employees.
											</li>
											<li>Let's group managers counting average salary:
<!-- start -->
<pre>
SELECT b.emp_id AS "Manager_Id", b.emp_name AS "Manager", AVG(b.salary) AS "Avg_Salary_Under_Manager"
FROM employees a, employees b
WHERE a.manager_id = b.emp_id
GROUP BY b.emp_id
ORDER BY b.emp_id;
</pre>
<!-- end -->
												<table style="font-size:16px;">
													<tbody>
														<tr>
															<th>Manager_Id</th>
															<th>Manager</th>
															<th>Average_Salary_Under_Manager</th>
														</tr>
														<tr>
															<td>16</td>
															<td>Rajesh</td>
															<td>65000</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>62500</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>53750</td>
														</tr>
													</tbody>
												</table>
											</li>
										</ul>

										<h5 id="case">CASE</h5>
										<ul>
											<li>We can use Case to give some conditons:
												<br>
												- assuming we have tblTest table and Nmbr filed,<br>
												- tblTest has 50 rows and Nmbr field contains 1s and 0s,<br>
												- let's replace 1s with 11s and 0s with 10s:
<!-- start -->
<pre>
UPDATE tblTest SET Nmbr = case
 WHEN Nmbr = 0 THEN 10
 ELSE 11 END;
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="in">IN</h5>
										<ul>
											<li>The IN operator allows to specify multiple values in a WHERE clause.</li>
											<li>If taken value 'Apple' is in one of given caolumns then we take rows into results.</li><br>
												<table style="font-size:16px;">
													<tr>
														<td>Id</td>
														<td>Col1</td>
														<td>Col2</td>
														<td>Col3</td>
													</tr>
													<tr>
														<td>1</td>
														<td>Apple</td>
														<td>Null</td>
														<td>Orange</td>
													</tr>
													<tr>
														<td>2</td>
														<td>Orange</td>
														<td>Apple</td>
														<td>Strawberry</td>
													</tr>
													<tr>
														<td>3</td>
														<td>Strawberry</td>
														<td>Apple</td>
														<td>Orange</td>
													</tr>
												</table>
<!-- start -->
<pre>
SELECT * FROM table
WHERE 'Apple' IN (Col1, Col2 Col3)
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="over">OVER</h5>
										<ul>
											<li>A <span id="window_functions"><b>window function</b></span> is an SQL function where the input values are taken from a "window" of one or more rows in the results set of a SELECT statement.
													Window functions are distinguished from other SQL functions by the presence of an <b>OVER clause</b>.
											</li>
											<li>OVER clause has been added to SQL Server and can be used to determine which rows from the query are applied to the function.</li>
											<li><b>PARTITION BY clause</b> is used to divide the result set from the query into data subsets, or partitions.
													PARTITION BY clause is not used, the entire result set from the query is the partition that will be used.
													The window function being used is applied to each partition separately, and the computation that the function performs is restarted for each partition.
													Lets have a look at example without OVER and with OVER applied:
<!-- start -->
<pre>
SELECT  object_id, index_id, COUNT(*) OVER ()
FROM objects
</pre>
<!-- end -->						<br>
												<table>
													<tr>
														<td>obj_id</td>
														<td>index_id</td>
														<td>no_col_name</td>
													</tr>
													<tr>
														<td>3</td>
														<td>1</td>
														<td>500</td>
													</tr>
													<tr>
														<td>5</td>
														<td>1</td>
														<td>500</td>
													</tr>
													<tr>
														<td>6</td>
														<td>1</td>
														<td>500</td>
													</tr>
													<tr>
														<td>7</td>
														<td>1</td>
														<td>500</td>
													</tr>
													<tr>
														<td>7</td>
														<td>2</td>
														<td>500</td>
													</tr>
													<tr>
														<td>8</td>
														<td>0</td>
														<td>500</td>
													</tr>
													<tr>
														<td>...</td>
														<td>...</td>
														<td>...</td>
													</tr>
												</table>
												<span style="font-size:12px;">source: sqlservercentral.com</span><br>
												- This query returns the <b>object_id</b> and <b>index_id</b> for each record, and the total number of indexes in the result set.<br>
												- Since a PARTITION BY clause was not used, the entire result set was treated as a single partition.<br>
												- Let's apply PARTITION BY clause:
<!-- start -->
<pre>
SELECT object_id, index_id, COUNT(*) OVER (PARTITION BY object_id)
FROM objects
</pre>
<!-- end -->
												<table>
													<tr>
														<td>obj_id</td>
														<td>index_id</td>
														<td>no_col_name</td>
													</tr>
													<tr>
														<td>3</td>
														<td>1</td>
														<td>1</td>
													</tr>
													<tr>
														<td>5</td>
														<td>1</td>
														<td>1</td>
													</tr>
													<tr>
														<td>6</td>
														<td>1</td>
														<td>1</td>
													</tr>
													<tr>
														<td>7</td>
														<td>1</td>
														<td>2</td>
													</tr>
													<tr>
														<td>7</td>
														<td>2</td>
														<td>2</td>
													</tr>
													<tr>
														<td>8</td>
														<td>0</td>
														<td>1</td>
													</tr>
													<tr>
														<td>...</td>
														<td>...</td>
														<td>...</td>
													</tr>
												</table>
												<span style="font-size:12px; margin-top: -20px;">source: sqlservercentral.com</span><br>
												- Above query specifies a PARTITION BY clause of the object_id column, so the count function is returning the number of indexes on that particular object_id.
													For example obj_id has been counted to 2 in no_col_name.
											</li>
										</ul>

										<h5 id="offset">OFFSET</h5>
										<ul>
											<li>The OFFSET clause specifies the number of rows to skip before starting to return rows from the query.
													The <span id="fetch">FETCH</span> clause specifies the number of rows to return after the OFFSET clause has been processed.</li>
											<li>We must use the OFFSET and FETCH clauses with the ORDER BY clause.</li>
											<li>Skipping the first 10 products and selecting the next 10 products:
<!-- start -->
<pre>
SELECT product, price
FROM products
ORDER BY price, product
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY;
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="exist">Exist</h5>
										<ul>
											<li>The EXISTS operator is used to test for the existence of any record in a subquery.</li>
											<li>The EXISTS operator returns true if the subquery returns one or more records:
<!-- start -->
<pre>
SELECT SupplierName
FROM Suppliers
WHERE EXISTS (
  SELECT ProductName
  FROM Products
  WHERE Products.SupplierID = Suppliers.SupplierID AND Price < 20)
</pre>
<!-- end -->
											- Above query returns TRUE and lists the suppliers with a product price less than 20:
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">SQL</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>Application:</h5>
									<img src="images/sql_learn.gif">
									<ul>
										<li>User click Get Questions button what pulls questions down to the application.</li>
										<li>Each question and answer is hidden. We can click on the proper links to unhide question.</li>
										<li>User can unhide question first, formulate its answer, then unhide the app's answer in order to comapre.</li>
									</ul>

									<h5>Features:</h5>
									<ul>
										<li>NodeJS - server-side API sevice to handle application's HTTP requests.</li>
										<li>MongoDB Atlas - server connects cloud data storage where I keep question-answer documents that are pulled to application.</li>
										<li>RactJS - front-end.</li>
										<li>ExpressJS - web framework that supports building API interfaces.</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<h5>No specific installation required.</h5>
									<ul>
										<li>npm</li>
										<li>ReactJs</li>
										<li>ExpressJS</li>
									</ul>
								</div>
							</section>

							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="https://github.com/ArturSkrzeta/Learn-SQL-Application/tree/main/project">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
			<script src="assets/js/scrolla.js"></script>
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
